{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"BioReport","text":"<p>A package for processing bioinformatics reports.</p> <p>Current version supports the following report types:</p> <ul> <li>fastp-json</li> <li>fastp-html</li> <li>bismark-align</li> <li>bismark-deduplicate</li> </ul> <p>The package is still under development. The framework is designed to be extensible. More report types will be supported in the future.</p>"},{"location":"#install","title":"Install","text":"<pre><code>git clone https://github.com/LawrenceLiu023/bioreport.git\npip install bioreport\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Quick start:</p> <pre><code>import bioreport\nimport pandas as pd\n\n# Scan a directory for reports.\nreport_list = bioreport.scan_dir(\"/path/to/report/dir\")\n\n# Parse all the reports found.\nreport_sum_list = [r.parse() for r in report_list]\n\n# Combine the parsed reports.\ncombined_report = bioreport.ReportSum.concat(report_sum_list)\n</code></pre> <p>For more details, please see the documentation.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>bioreport<ul> <li>report</li> <li>report_sum</li> <li>search</li> </ul> </li> </ul>"},{"location":"reference/bioreport/report/","title":"report","text":"<p>Process bioinformatics report.</p>"},{"location":"reference/bioreport/report/#bioreport.report.Report","title":"<code>Report</code>","text":"<p>A class represent different types of report files.</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>Path</code> <p>The path to the report file.</p> <code>module</code> <code>tuple[str, ...]</code> <p>The type of the file. The length of the tuple could be 0, 1 or 2.</p> <p>Methods:</p> Name Description <code>with_empty_module</code> <p>Check if the module is empty.</p> <code>match_file</code> <p>Match a single file. Determine which type of report it is and return a <code>Report</code> object.</p> <code>with_matched_module</code> <p>Check if the <code>module</code> of the <code>Report</code> object is matched with the actual pattern of the file specified by <code>path</code>. Return <code>True</code> if the <code>module</code> is matched, otherwise return <code>False</code>.</p> <code>update_module</code> <p>Update the <code>module</code> of the <code>Report</code> object with the actual pattern of the file specified by <code>path</code>.</p> <code>parse</code> <p>Parse the report file. Return a <code>ReportSum</code> object.</p> Source code in <code>bioreport\\report.py</code> <pre><code>class Report:\n    \"\"\"\n    A class represent different types of report files.\n\n    Attributes\n    ----------\n    path : pathlib.Path\n        The path to the report file.\n    module : tuple[str, ...]\n        The type of the file. The length of the tuple could be 0, 1 or 2.\n\n    Methods\n    -------\n    with_empty_module() -&gt; None\n        Check if the module is empty.\n    match_file(file_name: str) -&gt; Report\n        Match a single file. Determine which type of report it is and return a `Report` object.\n    with_matched_module() -&gt; bool\n        Check if the `module` of the `Report` object is matched with the actual pattern of the file specified by `path`. Return `True` if the `module` is matched, otherwise return `False`.\n    update_module() -&gt; None\n        Update the `module` of the `Report` object with the actual pattern of the file specified by `path`.\n    parse(update_module: bool = False, *, name: Hashable | None = None) -&gt; ReportSum\n        Parse the report file. Return a `ReportSum` object.\n    \"\"\"\n\n    def __init__(\n        self: Self, path: str | pathlib.Path, module: tuple[str, ...] = tuple()\n    ) -&gt; None:\n        self.path: pathlib.Path\n        if isinstance(path, str):\n            self.path = pathlib.Path(path).absolute()\n        elif isinstance(path, pathlib.Path):\n            self.path = path.absolute()\n        else:\n            raise TypeError(f\"Invalid type of path: {type(path)}\")\n        self.module: tuple[str, ...] = module\n\n    def __repr__(self: Self) -&gt; str:\n        report_string: str = (\n            f'{self.__class__.__name__}(path: \"{str(self.path)}\", type: \"{self.module}\")'\n        )\n        return report_string\n\n    def __eq__(self: Self, other: Any) -&gt; bool:\n        is_eq: bool\n        if not isinstance(other, Report):\n            is_eq = False\n            return is_eq\n        is_eq = self.path == other.path and self.module == other.module\n        return is_eq\n\n    def with_empty_module(self: Self) -&gt; bool:\n        \"\"\"\n        Check if the module is empty.\n\n        Returns\n        -------\n        with_empty_module : bool\n            The `module` is empty.\n        \"\"\"\n        return len(self.module) == 0\n\n    @classmethod\n    def match_file(cls, file: str | pathlib.Path) -&gt; Self:\n        \"\"\"\n        Match a single file. Determine which type of report it is and return a `Report` object.\n\n        Parameters\n        ----------\n        file : str | pathlib.Path\n            The file to match.\n\n        Returns\n        -------\n        report : Report\n            The type of the file. The length of the tuple could be 0, 1 or 2.\n        \"\"\"\n        file_path: pathlib.Path\n        if isinstance(file, str):\n            file_path = pathlib.Path(file).absolute()\n        elif isinstance(file, pathlib.Path):\n            file_path = file.absolute()\n        else:\n            raise TypeError(\"file must be a string or pathlib.Path object\")\n\n        file_module_match: tuple[str, ...] = tuple()\n\n        report: Report\n        if not file_path.is_file():\n            report = Report(path=file_path, module=file_module_match)\n            return report\n\n        def file_name_glob_check(\n            file_path: pathlib.Path, module_patterns: dict[str, str]\n        ) -&gt; bool:\n            pass_check: bool = True\n            if (key_file_name_glob := \"pattern_glob\") in module_patterns.keys():\n                file_path_glob_match_list: list = list(\n                    file_path.parent.glob(module_patterns[key_file_name_glob])\n                )\n                if file_path not in file_path_glob_match_list:\n                    pass_check = False\n            return pass_check\n\n        def file_name_regex_check(\n            file_path: pathlib.Path, module_patterns: dict[str, str]\n        ) -&gt; bool:\n            pass_check: bool = True\n            if (key_file_name_regex := \"pattern_regex\") in module_patterns.keys():\n                file_path_regex_match: re.Match[str] | None = re.match(\n                    pattern=module_patterns[key_file_name_regex],\n                    string=str(file_path.name),\n                )\n                if file_path_regex_match is None:\n                    pass_check = False\n            return pass_check\n\n        def file_content_regex_check(\n            file_path: pathlib.Path, module_patterns: dict[str, str]\n        ) -&gt; bool:\n            pass_check: bool = True\n            if (key_context_regex := \"content_regex\") in module_patterns.keys():\n                module_content_regex_line_list: list[str] = module_patterns[\n                    key_context_regex\n                ].splitlines()\n                module_content_regex_line_num: int = len(module_content_regex_line_list)\n                with open(file_path, \"r\") as f:\n                    file_content_line_list: list[str] = f.readlines(\n                        module_content_regex_line_num\n                    )\n                content_regex_match: re.Match[str] | None = re.match(\n                    pattern=r\"\\s+\".join(module_content_regex_line_list),\n                    string=\"\\n\".join(file_content_line_list),\n                )\n                if content_regex_match is None:\n                    pass_check = False\n            return pass_check\n\n        # match all report patterns\n        module_name_matched_set: set[str] = set()\n        module_name: str\n        module_patterns: dict[str, str]\n        for module_name, module_patterns in _config.REPORT_PATTERN.items():\n            module_patterns_check: bool = (\n                file_name_glob_check(\n                    file_path=file_path, module_patterns=module_patterns\n                )\n                and file_name_regex_check(\n                    file_path=file_path, module_patterns=module_patterns\n                )\n                and file_content_regex_check(\n                    file_path=file_path, module_patterns=module_patterns\n                )\n            )\n            if module_patterns_check:\n                module_name_matched_set.add(module_name)\n\n        if len(module_name_matched_set) == 0:\n            report = Report(path=file_path, module=file_module_match)\n            return report\n        elif len(module_name_matched_set) &gt; 1:\n            raise ValueError(\n                f\"Too many types of report has been matched: {file_path} -&gt; {module_name_matched_set}. This error could be due to incorrect configuration of report patterns.\"\n            )\n\n        file_module_match = tuple(\n            list(module_name_matched_set)[0].split(_config.REPORT_PATTERN_NAME_SEP)\n        )\n        report = Report(path=file_path, module=file_module_match)\n        return report\n\n    def with_matched_module(self: Self) -&gt; bool:\n        \"\"\"\n        Check if the `module` of the `Report` object is matched with the actual pattern of the file specified by `path`. Return `True` if the `module` is matched, otherwise return `False`.\n\n        Returns\n        -------\n        is_matched : bool\n            Whether the `module` is matched. `True` if the `module` is matched, otherwise return `False`.\n        \"\"\"\n        is_matched: bool\n        actual_match_result: Report = self.match_file(file=self.path)\n        if actual_match_result.module == self.module:\n            is_matched = True\n        else:\n            is_matched = False\n        return is_matched\n\n    def update_module(self: Self) -&gt; None:\n        \"\"\"Update the `module` of the `Report` object with the actual pattern of the file specified by `path`.\"\"\"\n        updated_report: Report = self.match_file(file=self.path)\n        self.module = updated_report.module\n\n    def parse(\n        self: Self, update_module: bool = False, *, name: Hashable | None = None\n    ) -&gt; ReportSum:\n        \"\"\"\n        Parse the report file. Return a `ReportSum` object.\n\n        Parameters\n        ----------\n        update_module : bool\n            Whether update the `module` of the `Report` object with the actual pattern of the file specified by `path`.\n\n        Returns\n        -------\n        report_sum : ReportSum\n            The parsed report.\n        \"\"\"\n        # update the `module`\n        if update_module:\n            updated_report: Report = self.match_file(file=self.path)\n            self.module = updated_report.module\n        # check `module`\n        if not self.with_matched_module():\n            raise ValueError(\n                f\"The report file pattern does not match the module specified: {str(self)}\"\n            )\n        # empty `module`\n        if self.with_empty_module():\n            raise ValueError(\n                f\"The report file does not match any module pattern: {str(self)}\"\n            )\n\n        module_name: str = self.module[0]\n        module = import_module(\n            name=f\".{_config.MODULES_DIR_BASENAME}.{module_name}\",\n            package=_config.PACKAGE_NAME,\n        )\n        report_sum: ReportSum = module.BioReportModule().parse(report=self, name=name)\n\n        return report_sum\n</code></pre>"},{"location":"reference/bioreport/report/#bioreport.report.Report.match_file","title":"<code>match_file(file)</code>  <code>classmethod</code>","text":"<p>Match a single file. Determine which type of report it is and return a <code>Report</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str | Path</code> <p>The file to match.</p> required <p>Returns:</p> Name Type Description <code>report</code> <code>Report</code> <p>The type of the file. The length of the tuple could be 0, 1 or 2.</p> Source code in <code>bioreport\\report.py</code> <pre><code>@classmethod\ndef match_file(cls, file: str | pathlib.Path) -&gt; Self:\n    \"\"\"\n    Match a single file. Determine which type of report it is and return a `Report` object.\n\n    Parameters\n    ----------\n    file : str | pathlib.Path\n        The file to match.\n\n    Returns\n    -------\n    report : Report\n        The type of the file. The length of the tuple could be 0, 1 or 2.\n    \"\"\"\n    file_path: pathlib.Path\n    if isinstance(file, str):\n        file_path = pathlib.Path(file).absolute()\n    elif isinstance(file, pathlib.Path):\n        file_path = file.absolute()\n    else:\n        raise TypeError(\"file must be a string or pathlib.Path object\")\n\n    file_module_match: tuple[str, ...] = tuple()\n\n    report: Report\n    if not file_path.is_file():\n        report = Report(path=file_path, module=file_module_match)\n        return report\n\n    def file_name_glob_check(\n        file_path: pathlib.Path, module_patterns: dict[str, str]\n    ) -&gt; bool:\n        pass_check: bool = True\n        if (key_file_name_glob := \"pattern_glob\") in module_patterns.keys():\n            file_path_glob_match_list: list = list(\n                file_path.parent.glob(module_patterns[key_file_name_glob])\n            )\n            if file_path not in file_path_glob_match_list:\n                pass_check = False\n        return pass_check\n\n    def file_name_regex_check(\n        file_path: pathlib.Path, module_patterns: dict[str, str]\n    ) -&gt; bool:\n        pass_check: bool = True\n        if (key_file_name_regex := \"pattern_regex\") in module_patterns.keys():\n            file_path_regex_match: re.Match[str] | None = re.match(\n                pattern=module_patterns[key_file_name_regex],\n                string=str(file_path.name),\n            )\n            if file_path_regex_match is None:\n                pass_check = False\n        return pass_check\n\n    def file_content_regex_check(\n        file_path: pathlib.Path, module_patterns: dict[str, str]\n    ) -&gt; bool:\n        pass_check: bool = True\n        if (key_context_regex := \"content_regex\") in module_patterns.keys():\n            module_content_regex_line_list: list[str] = module_patterns[\n                key_context_regex\n            ].splitlines()\n            module_content_regex_line_num: int = len(module_content_regex_line_list)\n            with open(file_path, \"r\") as f:\n                file_content_line_list: list[str] = f.readlines(\n                    module_content_regex_line_num\n                )\n            content_regex_match: re.Match[str] | None = re.match(\n                pattern=r\"\\s+\".join(module_content_regex_line_list),\n                string=\"\\n\".join(file_content_line_list),\n            )\n            if content_regex_match is None:\n                pass_check = False\n        return pass_check\n\n    # match all report patterns\n    module_name_matched_set: set[str] = set()\n    module_name: str\n    module_patterns: dict[str, str]\n    for module_name, module_patterns in _config.REPORT_PATTERN.items():\n        module_patterns_check: bool = (\n            file_name_glob_check(\n                file_path=file_path, module_patterns=module_patterns\n            )\n            and file_name_regex_check(\n                file_path=file_path, module_patterns=module_patterns\n            )\n            and file_content_regex_check(\n                file_path=file_path, module_patterns=module_patterns\n            )\n        )\n        if module_patterns_check:\n            module_name_matched_set.add(module_name)\n\n    if len(module_name_matched_set) == 0:\n        report = Report(path=file_path, module=file_module_match)\n        return report\n    elif len(module_name_matched_set) &gt; 1:\n        raise ValueError(\n            f\"Too many types of report has been matched: {file_path} -&gt; {module_name_matched_set}. This error could be due to incorrect configuration of report patterns.\"\n        )\n\n    file_module_match = tuple(\n        list(module_name_matched_set)[0].split(_config.REPORT_PATTERN_NAME_SEP)\n    )\n    report = Report(path=file_path, module=file_module_match)\n    return report\n</code></pre>"},{"location":"reference/bioreport/report/#bioreport.report.Report.parse","title":"<code>parse(update_module=False, *, name=None)</code>","text":"<p>Parse the report file. Return a <code>ReportSum</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>update_module</code> <code>bool</code> <p>Whether update the <code>module</code> of the <code>Report</code> object with the actual pattern of the file specified by <code>path</code>.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>report_sum</code> <code>ReportSum</code> <p>The parsed report.</p> Source code in <code>bioreport\\report.py</code> <pre><code>def parse(\n    self: Self, update_module: bool = False, *, name: Hashable | None = None\n) -&gt; ReportSum:\n    \"\"\"\n    Parse the report file. Return a `ReportSum` object.\n\n    Parameters\n    ----------\n    update_module : bool\n        Whether update the `module` of the `Report` object with the actual pattern of the file specified by `path`.\n\n    Returns\n    -------\n    report_sum : ReportSum\n        The parsed report.\n    \"\"\"\n    # update the `module`\n    if update_module:\n        updated_report: Report = self.match_file(file=self.path)\n        self.module = updated_report.module\n    # check `module`\n    if not self.with_matched_module():\n        raise ValueError(\n            f\"The report file pattern does not match the module specified: {str(self)}\"\n        )\n    # empty `module`\n    if self.with_empty_module():\n        raise ValueError(\n            f\"The report file does not match any module pattern: {str(self)}\"\n        )\n\n    module_name: str = self.module[0]\n    module = import_module(\n        name=f\".{_config.MODULES_DIR_BASENAME}.{module_name}\",\n        package=_config.PACKAGE_NAME,\n    )\n    report_sum: ReportSum = module.BioReportModule().parse(report=self, name=name)\n\n    return report_sum\n</code></pre>"},{"location":"reference/bioreport/report/#bioreport.report.Report.update_module","title":"<code>update_module()</code>","text":"<p>Update the <code>module</code> of the <code>Report</code> object with the actual pattern of the file specified by <code>path</code>.</p> Source code in <code>bioreport\\report.py</code> <pre><code>def update_module(self: Self) -&gt; None:\n    \"\"\"Update the `module` of the `Report` object with the actual pattern of the file specified by `path`.\"\"\"\n    updated_report: Report = self.match_file(file=self.path)\n    self.module = updated_report.module\n</code></pre>"},{"location":"reference/bioreport/report/#bioreport.report.Report.with_empty_module","title":"<code>with_empty_module()</code>","text":"<p>Check if the module is empty.</p> <p>Returns:</p> Name Type Description <code>with_empty_module</code> <code>bool</code> <p>The <code>module</code> is empty.</p> Source code in <code>bioreport\\report.py</code> <pre><code>def with_empty_module(self: Self) -&gt; bool:\n    \"\"\"\n    Check if the module is empty.\n\n    Returns\n    -------\n    with_empty_module : bool\n        The `module` is empty.\n    \"\"\"\n    return len(self.module) == 0\n</code></pre>"},{"location":"reference/bioreport/report/#bioreport.report.Report.with_matched_module","title":"<code>with_matched_module()</code>","text":"<p>Check if the <code>module</code> of the <code>Report</code> object is matched with the actual pattern of the file specified by <code>path</code>. Return <code>True</code> if the <code>module</code> is matched, otherwise return <code>False</code>.</p> <p>Returns:</p> Name Type Description <code>is_matched</code> <code>bool</code> <p>Whether the <code>module</code> is matched. <code>True</code> if the <code>module</code> is matched, otherwise return <code>False</code>.</p> Source code in <code>bioreport\\report.py</code> <pre><code>def with_matched_module(self: Self) -&gt; bool:\n    \"\"\"\n    Check if the `module` of the `Report` object is matched with the actual pattern of the file specified by `path`. Return `True` if the `module` is matched, otherwise return `False`.\n\n    Returns\n    -------\n    is_matched : bool\n        Whether the `module` is matched. `True` if the `module` is matched, otherwise return `False`.\n    \"\"\"\n    is_matched: bool\n    actual_match_result: Report = self.match_file(file=self.path)\n    if actual_match_result.module == self.module:\n        is_matched = True\n    else:\n        is_matched = False\n    return is_matched\n</code></pre>"},{"location":"reference/bioreport/report_sum/","title":"report_sum","text":"<p>Summary of bioinformatics report.</p>"},{"location":"reference/bioreport/report_sum/#bioreport.report_sum.ReportSum","title":"<code>ReportSum</code>","text":"<p>A class to represent a summary of a report.</p> <p>Attributes:</p> Name Type Description <code>module</code> <code>tuple[str, ...]</code> <p>The module of the report.</p> <code>data</code> <code>Series</code> <p>The data of the report.</p> <code>name</code> <code>Hashable | None</code> <p>The name of the report.</p> <p>Methods:</p> Name Description <code>concat</code> <p>Concatenate multiple <code>ReportSum</code> objects into one.</p> Source code in <code>bioreport\\report_sum.py</code> <pre><code>class ReportSum:\n    \"\"\"\n    A class to represent a summary of a report.\n\n    Attributes\n    ----------\n    module : tuple[str, ...]\n        The module of the report.\n    data : pd.Series\n        The data of the report.\n    name : Hashable | None\n        The name of the report.\n\n    Methods\n    -------\n    concat(report_sums: Iterable[Self], join: Literal[\"inner\", \"outer\"] = \"outer\") -&gt; pd.DataFrame\n        Concatenate multiple `ReportSum` objects into one.\n    \"\"\"\n\n    def __init__(self, module: tuple[str, ...], data: pd.Series) -&gt; None:\n        self.module: tuple[str, ...] = module\n        self.data: pd.Series = data\n\n    @property\n    def name(self) -&gt; Hashable:\n        \"\"\"\n        Get the name of the `data`.\n\n        Returns\n        -------\n        name : Hashable\n            _description_\n        \"\"\"\n        name: Hashable | None = self.data.name\n        return name\n\n    def __repr__(self) -&gt; str:\n        return f'{self.__class__.__name__}(type: \"{self.module}\", name: \"{self.name}\")'\n\n    @classmethod\n    def concat(\n        cls, report_sums: Iterable[Self], join: Literal[\"inner\", \"outer\"] = \"outer\"\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Concatenate multiple `ReportSum` objects into one.\n\n        Parameters\n        ----------\n        report_sums : Iterable[Self]\n            Multiple `ReportSum` objects.\n        join : Literal[\"inner\", \"outer\"], optional\n            How to handle indexes on other axis (or axes).\n\n        Returns\n        -------\n        multi_report_sum : pd.DataFrame\n            A dataframe containing the concatenated data from all `ReportSum` objects.\n        \"\"\"\n        report_sum_module_list: list = [report_sum.module for report_sum in report_sums]\n        if len(set(report_sum_module_list)) &gt; 1:\n            error_modules_str: str = \",\".join(list(map(str, report_sum_module_list)))\n            raise ValueError(\n                f\"All report_sums must have the same module. The modules of the reports are: {error_modules_str}\"\n            )\n        multi_report_sum: pd.DataFrame = pd.concat(\n            [report_sum.data for report_sum in report_sums], axis=1, join=join\n        )\n        multi_report_sum = multi_report_sum.T\n        return multi_report_sum\n\n    def rename(self, name: Hashable | None) -&gt; None:\n        \"\"\"Change the name of the `data`.\"\"\"\n        self.data.name = name\n</code></pre>"},{"location":"reference/bioreport/report_sum/#bioreport.report_sum.ReportSum.name","title":"<code>name: Hashable</code>  <code>property</code>","text":"<p>Get the name of the <code>data</code>.</p> <p>Returns:</p> Name Type Description <code>name</code> <code>Hashable</code> <p>description</p>"},{"location":"reference/bioreport/report_sum/#bioreport.report_sum.ReportSum.concat","title":"<code>concat(report_sums, join='outer')</code>  <code>classmethod</code>","text":"<p>Concatenate multiple <code>ReportSum</code> objects into one.</p> <p>Parameters:</p> Name Type Description Default <code>report_sums</code> <code>Iterable[Self]</code> <p>Multiple <code>ReportSum</code> objects.</p> required <code>join</code> <code>Literal['inner', 'outer']</code> <p>How to handle indexes on other axis (or axes).</p> <code>'outer'</code> <p>Returns:</p> Name Type Description <code>multi_report_sum</code> <code>DataFrame</code> <p>A dataframe containing the concatenated data from all <code>ReportSum</code> objects.</p> Source code in <code>bioreport\\report_sum.py</code> <pre><code>@classmethod\ndef concat(\n    cls, report_sums: Iterable[Self], join: Literal[\"inner\", \"outer\"] = \"outer\"\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Concatenate multiple `ReportSum` objects into one.\n\n    Parameters\n    ----------\n    report_sums : Iterable[Self]\n        Multiple `ReportSum` objects.\n    join : Literal[\"inner\", \"outer\"], optional\n        How to handle indexes on other axis (or axes).\n\n    Returns\n    -------\n    multi_report_sum : pd.DataFrame\n        A dataframe containing the concatenated data from all `ReportSum` objects.\n    \"\"\"\n    report_sum_module_list: list = [report_sum.module for report_sum in report_sums]\n    if len(set(report_sum_module_list)) &gt; 1:\n        error_modules_str: str = \",\".join(list(map(str, report_sum_module_list)))\n        raise ValueError(\n            f\"All report_sums must have the same module. The modules of the reports are: {error_modules_str}\"\n        )\n    multi_report_sum: pd.DataFrame = pd.concat(\n        [report_sum.data for report_sum in report_sums], axis=1, join=join\n    )\n    multi_report_sum = multi_report_sum.T\n    return multi_report_sum\n</code></pre>"},{"location":"reference/bioreport/report_sum/#bioreport.report_sum.ReportSum.rename","title":"<code>rename(name)</code>","text":"<p>Change the name of the <code>data</code>.</p> Source code in <code>bioreport\\report_sum.py</code> <pre><code>def rename(self, name: Hashable | None) -&gt; None:\n    \"\"\"Change the name of the `data`.\"\"\"\n    self.data.name = name\n</code></pre>"},{"location":"reference/bioreport/search/","title":"search","text":"<p>Search for report files.</p>"},{"location":"reference/bioreport/search/#bioreport.search.scan_dir","title":"<code>scan_dir(dir)</code>","text":"<p>Scan a directory to find all the report files.</p> <p>Parameters:</p> Name Type Description Default <code>dir</code> <code>str | Path</code> <p>The directory to scan.</p> required <p>Returns:</p> Name Type Description <code>report_list</code> <code>list[Report]</code> <p>A list of <code>Report</code> objects. <code>Report.path</code> is the report file path. <code>Report.module</code> is a tuple of the type of the report.</p> Source code in <code>bioreport\\search.py</code> <pre><code>def scan_dir(dir: str | pathlib.Path) -&gt; list[Report]:\n    \"\"\"\n    Scan a directory to find all the report files.\n\n    Parameters\n    ----------\n    dir : str | pathlib.Path\n        The directory to scan.\n\n    Returns\n    -------\n    report_list : list[Report]\n        A list of `Report` objects. `Report.path` is the report file path. `Report.module` is a tuple of the type of the report.\n    \"\"\"\n    dir_path: pathlib.Path\n    if isinstance(dir, str):\n        dir_path = pathlib.Path(dir).absolute()\n    elif isinstance(dir, pathlib.Path):\n        dir_path = dir.absolute()\n    _logger.info(f\"Scanning directory: {str(dir_path)}\")\n\n    report_path_to_module_dict: dict[pathlib.Path, tuple[str, ...]] = {}\n    file_found_list: list[pathlib.Path] = []\n    for curr_root, _, curr_files in dir_path.walk():\n        curr_file_path_list: list[pathlib.Path] = [\n            pathlib.Path(curr_root) / f for f in curr_files\n        ]\n        file_found_list.extend(curr_file_path_list)\n    _logger.info(f\"Total number of files to match: {len(file_found_list)}\")\n    candidate_report_list: list[Report] = [\n        Report.match_file(f)\n        for f in track(sequence=file_found_list, description=\"Matching files...\")\n    ]\n    report_list: list[Report] = list(\n        filter(lambda x: not x.with_empty_module(), candidate_report_list)\n    )\n    return report_list\n</code></pre>"}]}